# -*- Mode:Org; Coding:utf-8; fill-column:158 -*-
# ######################################################################################################################################################.H.S.##
# FILE:        ColorSchemes.org
#+TITLE:       MRaster Color Schemes
#+AUTHOR:      Mitch Richling
#+EMAIL:       http://www.mitchr.me/
#+DATE:        2022-07-31
#+DESCRIPTION: DESCRIPTION FIXME
#+KEYWORDS:    KEYWORDS FIXME
#+LANGUAGE:    en
#+OPTIONS:     num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t skip:nil d:nil todo:t pri:nil H:5 p:t author:t html-scripts:nil 
#+SEQ_TODO:    TODO:NEW(t)                         TODO:WORK(w)    TODO:HOLD(h)    | TODO:FUTURE(f)   TODO:DONE(d)    TODO:CANCELED(c)
#+PROPERTY: header-args :eval never-export
#+HTML_HEAD: <style>body { width: 95%; margin: 2% auto; font-size: 18px; line-height: 1.4em; font-family: Georgia, serif; color: black; background-color: white; }</style>
#+HTML_HEAD: <style>body { min-width: 500px; max-width: 1024px; }</style>
#+HTML_HEAD: <style>h1,h2,h3,h4,h5,h6 { color: #A5573E; line-height: 1em; font-family: Helvetica, sans-serif; }</style>
#+HTML_HEAD: <style>h1,h2,h3 { line-height: 1.4em; }</style>
#+HTML_HEAD: <style>h1.title { font-size: 3em; }</style>
#+HTML_HEAD: <style>.subtitle { font-size: 0.6em; }</style>
#+HTML_HEAD: <style>h4,h5,h6 { font-size: 1em; }</style>
#+HTML_HEAD: <style>.org-src-container { border: 1px solid #ccc; box-shadow: 3px 3px 3px #eee; font-family: Lucida Console, monospace; font-size: 80%; margin: 0px; padding: 0px 0px; position: relative; }</style>
#+HTML_HEAD: <style>.org-src-container>pre { line-height: 1.2em; padding-top: 1.5em; margin: 0.5em; background-color: #404040; color: white; overflow: auto; }</style>
#+HTML_HEAD: <style>.org-src-container>pre:before { display: block; position: absolute; background-color: #b3b3b3; top: 0; right: 0; padding: 0 0.2em 0 0.4em; border-bottom-left-radius: 8px; border: 0; color: white; font-size: 100%; font-family: Helvetica, sans-serif;}</style>
#+HTML_HEAD: <style>pre.example { white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -o-pre-wrap; font-family: Lucida Console, monospace; font-size: 80%; background: #404040; color: white; display: block; padding: 0em; border: 2px solid black; }</style>
#+HTML_LINK_HOME: https://www.mitchr.me/
#+HTML_LINK_UP: http://richmit.github.io/mraster/index.html
# ######################################################################################################################################################.H.E.##

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
|          <r> | <l>                                          |
|    *Author:* | /{{{author}}}/                               |
|   *Updated:* | /{{{modification-time(%Y-%m-%d %H:%M:%S)}}}/ |
| *Generated:* | /{{{time(%Y-%m-%d %H:%M:%S)}}}/              |
#+ATTR_HTML: :align center
Copyright \copy {{{time(%Y)}}} Mitch Richling. All rights reserved.

#+TOC: headlines 5

#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #
#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #
#   010  #    020  #    030  #    040  #    050  #    060  #    070  #    080  #    090  #    100  #    110  #    120  #    130  #    140  #    150  #    160  #    170  #    180  #    190  #    200  #    210  #    220  #    230  #    240  #    250  #    260  #    270  #    280  #    290  #
# 345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #       | #         #         #         #         #         #         #         #         #         #         #         #         #         #
#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #       | #         #         #         #         #         #         #         #         #         #         #         #         #         #

# To get org to evaluate all code blocks on export, add the following to the Emacs header on the first line of this file:
#     org-export-babel-evaluate:t; org-confirm-babel-evaluate:nil
#
# C-c C-x C-v (org-toggle-inline-images)
#

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

*=MRaster=* provides access to a rich collection of color schemes.  Color schemes are exposed in the API as inner classes of the =colorTpl= class.  These
inner classes follow a regular naming convention:

  - =csCB ..........= RGB Color Brewer 2 (template: =csCB_tpl=
  - =csFPwebSafe ...= RGB Web safe colors (template: =csFP_tpl=
  - =csCCdiag ......= RGB color cube: diagonal gradients (template: =csCC_tpl=)
  - =csCCcons ......= RGB color cube: Gradients with constant brightness (template: =csCC_tpl=)
  - =csCColde ......= RGB color cube: Some classic color gradients (template: =csCC_tpl=)
  - =csCCud ........= RGB color cube: Two color up-down ramps (template: =csCC_tpl=)
  - =csCCSum .......= RGB color cube: Sum ramp (template: =csCC_tpl=)
  - =csHSLh ........= RGB color cube: Gradients starting at the center of the cube and extending to a corner
  - =csBin .........= RGB Binary Schemes (template: =csCC_tpl=)
  - =csPGrey .......= RGB Pseudo-greyscale
  - =csRainbow .....= RGB spectrum based colors
  - =csCH ..........= RGB Cubehelix colors (template: csCubeHelix_tpl)


These classes are static in nature, and an instance is not required to use them.  They all have a member named "=c=" which is used to set the components of a
=colorTpl= instance passed as argument, or as a factory for =colorTpl= instances.

When used as a factory, color scheme classes return fully constructed  =colorTpl=  objects:

#+begin_src c++
mjr:color3c8b aColor = mjr::color3c8b::webSafeNormalVision.c(25);
#+end_src

Alternately, color scheme classes may set the components of a passed  =colorTpl=  instance:

#+begin_src c++
mjr::color3c8b aColor;
mjr::color3c8b::webSafeNormalVision.c(aColor, 25);
#+end_src

Color scheme classes may also be used by =colorTpl= methods to identify a color scheme.  For example, the =csSet= method can set the current object's
components based on a color scheme like so:

#+begin_src c++
mjr::color3c8b aColor;
aColor.csSet<mjr::color3c8b::webSafeNormalVision>(25);
#+end_src

** Color Scheme Class Interface

Not all color scheme classes have the same interface; however, the interfaces are uniformly designed:
  - *=numC=:* The number of colors available in the scheme 
    - Color schemes with a fixed number of colors at compile time have member =numC=
    - Color schemes with the number of colors set at run time, will have a =numC= argument for the =c= methods.
      - These schemes have two members specifying the range for =numC=: =minNumC= & =maxNumC=.
  - *=c=:* methods are used to set colors
    - The =c= methods come in two general forms:
      - A =colorTpl= factory methodand that takes one or more arguments identifying the color within the color scheme
        - The first argument is a "locator" that selects a color in a scheme.  This locater takes one of three forms:
          - *=csIntType csInx=:* An integer "index" for descrete color schemes (like Colorbrewer schemes)
          - *=csFltType csX=:* A floating point value in [0, 1] used to select colors from continuous schemes (like gradiants)
          - *=csNatType csVal=:* These are highly dependant upon the color scheme.  See the =csHSLh*= schemes as an example.
        - The remaining arguments are generally used to specify some characterstic of the scheme itself.  Examples:
          - A =numC= argument specifying the number of elements in a discrete scheme (like Colorbrewer schemes)
          - The color match function based rainbow color schemes take an argument =interpMethod= specifiying an interpolation method. is 
      - A method that takes a =colorTpl= as it's first argument, with the remaining argument as in the factory method form of =c=.
      - It is entirely possilbe that a color scheme object may have more than two =c= methods.  For example, a discrete and continous versions of =c= for
        color schems that may be used both ways.

Many color schemes provide a number of colors that is a function of =chanStepMax=, which is directly related to the value of =clrChanT=.  For integral
=clrChanT= types, =chanStepMax= will be equal to =maxChanVal=. For floating point =clrChanT= types, =chanStepMax= will be equal to $2^32$.

* Color Cube Edge/Diagonal Graph Color Schemes

 The RGB color cube:

#+begin_src text
.                                                       _________________________
.                                                green / _____________________  /| yellow
.                                                     / / ___________________/ / |
.                                                    / / /| |               / /  |
.                                                   / / / | |              / / . |
.                                                  / / /| | |             / / /| |
.                                                 / / / | | |            / / / | |
.                                                / / /  | | |     white / / /| | |
.                                               / /_/__________________/ / / | | |
.                                              /________________________/ /  | | |
.                                         cyan | ______________________ | |  | | |
.                                              | | |    | | |_________| | |__| | |
.                                              | | |    | |___________| | |____| |
.                                              | | |   / / ___________| | |_  / / red
.                                              | | |  / / /           | | |/ / /
.                                              | | | / / /  black     | | | / /
.                                              | | |/ / /             | | |/ /
.                                              | | | / /              | | ' /
.                                              | | |/_/_______________| |  /
.                                              | |____________________| | /
.                                         blue |________________________|/ magenta
.                           
.                                       Vertexes and Center of the RGB Color Cube:
.                                       Name     R     G     B     Abriv
.                                       black    0.0   0.0   0.0   0
.                                       blue     0.0   0.0   1.0   b
.                                       green    0.0   1.0   0.0   g
.                                       red      1.0   0.0   0.0   r
.                                       yellow   1.0   1.0   0.0   y
.                                       cyan     0.0   1.0   1.0   c
.                                       magenta  1.0   0.0   1.0   m
.                                       white    1.0   1.0   1.0   w
.                                       grey50   0.5   0.5   0.5   h
#+end_src

The RGB color cube is usually considered as part of the 3D Euclidean space $\mathbb{R}^3$ -- that is $R$, $G$, & $B$ are real values in $I=[0, 1]$.  This
subset of $\mathbb{R}^3$ is frequently called the "unit cube" and denoted by $I^3$.  A gradient in this context is a continuous curve, $c:I\rightarrow I^3$, from one
point in the cube to another.  In this way we define an infinite sequence of colors.  The most popular gradients are straight lines connecting two colors
together.  The next most popular is a pairwise linear curve connecting several colors together -- usually with each linear component the same length.

Digital images are mos commonly represented with integer values for $R$, $G$, & $B$.  Most commonly unsigned, 8-bit integers -- $0.0$ mapping to $0$ and $1.0$
mapping to $255$.  In this scenario one might think of the RGB color space as a discrete set of $16777216$ values, and color gradients as finite sequences of
discrete "steps" from one discrete color value to another.  For example, a linear gradient from "green" to "yellow" will have precisely $256$ unique steps when
the color space is defined in terms of 8-bit, integer color channels.  Note that a linear gradient from "green" to "magenta", across the diagonal of the cube,
will also have $256$ color steps -- one of the oddities of distance measurement the discrete RGB space!  Lastly, note that if we had a gradient from "green"
through "yellow" and ending at "red", we would have have $511$ distinct colors.  So discreet RGB color spaces produce discreet gradients, and the number of
colors in the gradient will differ depending on the points traversed.

The corners of the color cube are by far the most popular choices for gradient control points.  In describing these gradients it is usefully to think about
the corners and how we can connect them as a mathematical graph.

The edges of the cube taken with the corners as vertexes form a graph (referred to as "the cube edge graph" in this documentation).  Every trail (a walk with
unique edges) with $n$ edges generates a color scheme with $\mathrm{maxChanVal}\cdot n - 1$ unique colors.  To make this scheme unique, we define the tree to
have one of its end points the "start" of the scheme -- so we can map the integers from $[0,\mathrm{maxChanVal}\cdot n]$ to unique colors.

 Example:

#+BEGIN_QUOTE
    ="BCG"= defines a trail starting at =B= (blue), moving to =C= (cyan) next, and ending at =G= (green).  The color scheme has $0$ mapped to blue (the first
    vertex), $256$ mapped to cyan (the second vertex), and $511$ mapped to green (the final vertex).  For values between two vertex points, we linearly
    interpolate between the two values.
#+END_QUOTE

If we expand the graph to also include edges between the diagonal points of each face (cyan to yellow for example), we have a larger graph with more options.
This graph is referred to as "the face edge/diagonal graph" in this documentation.

Lastly, we can expand that graph by adding one vertex, called =h=, at the center of the cube with edges extending to each corner.  This graph is referred to
as "complete cube graph with center" in this documentation.

Every color scheme in this section can be created via the =cmpRGBcornerGradiant()= method of =colorTpl=; however, many are also available as predefined color
scheme objects.  The color schemes provided by the =csCC_tpl= template provide a dual interface.  One provides a discreet view of gradients (the =c= methods
with =csIdx= arguments), and the other provides a continuous view of gradients (the =c= methods with =csX= arguments).  When the colors use floating point
channels, the discreet gradients have $2^{32}$ steps between corner colors.

** Maximal circuits in the cube edge graph

 This is one of the most commonly seen color schemes in scientific visualization.  The color cube rainbow map is generated by the unique six segment (6
 vertex) cycle in the face edge graph not involving white or black:

  - =RYGCBMR= -- =csCColdeRainbow=

*** Predefined Schemes
 - =csCColdeRainbow= :: \\
  [[./pics/cs/color_lut_docs_csCColdeRainbow_50.png]]

** Maximal circuits in the cube edge/diagonal graph

 If we expand to the edge face/diagonal graph, then we have may more six segment cycles not involving white or black:

  - =RBCGYMR=
  - =RBCMYGR=
  - =RBGCMYR=
  - =RBGCYMR=
  - =RBGYCMR=
  - =RBMCGYR=
  - =RBMCYGR=
  - =RBMYCGR=
  - =RGBCMYR=
  - =RGBCYMR=
  - =RGBMCYR=
  - =RGCBMYR=
  - =RGYCBMR=
  - =RMBGCYR=
  - =RMCBGYR=

** Hitting all the corners

  A common request is for a cycle in the face edge graph that uses every corner color of the RGB cube.  Not only do we have one, but 6 uniquely
  different ones -- not counting rearrangements or reversals:

   - =0BCGYWMR0=
   - =0BCWMRYG0=
   - =0BMRYWCG0=
   - =0BMWCGYR0=
   - =0GCBMWYR0=
   - =0GYWCBMR0=

** Large Trees

  Another common request is for trees (so no color is used twice) starting at black and ending at white.  Several trees exist of lengths of 7 and 5:

   - =0BCGYRMW=
   - =0BMRYGCW=
   - =0GCBMRYW=
   - =0GYRMBCW=
   - =0RMBCGYW=
   - =0RYGCBMW=
   - =0BCGYW=
   - =0BMRYW=
   - =0GCBMW=
   - =0GYRMW=
   - =0RMBCW=
   - =0RYGCW=

** Black to White Trees

  The three segment trees from black to white are useful in that the intensity (sum of the components) is a monotone increasing function from zero up to
  three.  One of them (=0RYW=) is often called the "fire ramp" as it ranges from black (flame base), up to yellow, then red, and finally to white hot.

   - =0BCW= -- =csCCsumBGR=                     
   - =0BMW= -- =csCCsumBRG=                     
   - =0GCW= -- =csCCsumGBR=                     
   - =0GYW= -- =csCCsumGRB=                     
   - =0RMW= -- =csCCsumRBG=                     
   - =0RYW= -- =csCCsumRGB= & =csCColdeFireRamp=

*** Predefined Schemes
 - =csCCsumBGR= :: \\
  [[./pics/cs/color_lut_docs_csCCsumBGR_50.png]]
 - =csCCsumBRG= :: \\
  [[./pics/cs/color_lut_docs_csCCsumBRG_50.png]]
 - =csCCsumGBR= :: \\
  [[./pics/cs/color_lut_docs_csCCsumGBR_50.png]]
 - =csCCsumGRB= :: \\
  [[./pics/cs/color_lut_docs_csCCsumGRB_50.png]]
 - =csCCsumRBG= :: \\
  [[./pics/cs/color_lut_docs_csCCsumRBG_50.png]]
 - =csCCsumRGB= & =csCColdeFireRamp= :: \\
  [[./pics/cs/color_lut_docs_csCCsumRGB_50.png]]

** Luminance based color schemes

  Luminance based color schemes defined as color gradients from the center of the in the HSL color space to an extreem vertex are quite popular.  Many of the
  most popular luminance based color schemes in the HSL color space are also edge graphs in the RGB color cube!  Of particular note, are the two segment trees
  from black to white in the RGB edge/diagonal graph -- they are the same as the two segment graphs in the edges of the HSL hexcone from black to white!

   - =0RW= -- =H=000= -- red edge of the HSL hexcone
   - =0YW= -- =H=060= -- yellow edge of the HSL hexcone
   - =0GW= -- =H=120= -- green edge of the HSL hexcone
   - =0CW= -- =H=180= -- cyan edge of the HSL hexcone
   - =0BW= -- =H=240= -- blue edge of the HSL hexcone
   - =0MW= -- =H=300= -- magenta edge of the HSL hexcone

** Hot Too Cold

 A very common color map used to map data with ranges from cold up to hot is known as the "cold too hot ramp".  This ramp provides colors from blue, up
 through green, and ends in red. It suffers from the same defects as the color cube rainbow; however, its use is so common that special support is provided
 via a named method.

  - =BCGYR= -- =csCColdeColdToHot=

 The traditional cold to hot ramp can be improved -- this is my personal opinion.  This new ramp still has the same problems the color cube rainbow has;
 however, it is more attractive.  This one moves from white (ice), up to water (blue), and then up to red (hot) via yellow.

  - =WCBYR= -- =csCColdeIceToWaterToHot=

*** Predefined Schemes
 - =csCColdeColdToHot= :: \\
  [[./pics/cs/color_lut_docs_csCColdeColdToHot_50.png]]
 - =csCColdeIceToWaterToHot= :: \\
  [[./pics/cs/color_lut_docs_csCColdeIceToWaterToHot_50.png]]

** Constant Intensity Cycles

 Two cycles, with three edges each, exhibiting constant intensity for every color in the color scheme are genuinely useful.  They have the advantage that they
 always render a "bright" color.  The lower intensity version is best for projected media that don't do well with yellow.

  - =CMY= -- =csCCconsTwo= -- intensity == 2
  - =BRG= -- =csCCconsOne= -- intensity == 1

*** Predefined Schemes
 - =csCCconsTwo= :: \\
  [[./pics/cs/color_lut_docs_csCCconsTwo_50.png]]
 - =csCCconsOne= :: \\
  [[./pics/cs/color_lut_docs_csCCconsOne_50.png]]

** One Segment Diverging Maps

 One edge trees in the face diagonal graph with a nearly constant intensity of 2 along the entire edge are useful for "diverging" or "bipolar" color
 schemes.  By definition, such color schemes will never involve black or white.

 While rarely used, the following maps are useful and suggested.  None of them have the problems associated with the color cube rainbow.

  - =YC= -- =csCCudBr=
  - =YM= -- =csCCudBg=
  - =MC= -- =csCCudGr=
  - =MY= -- =csCCudGb=
  - =CM= -- =csCCudRg=
  - =CY= -- =csCCudRb=

 The naming convention for the methods is not obvious.  Take, for example, setRGBcmpUpDownRampBr.  This is so named because of the computational algorithm
 used to compute the scheme: Blue up, red down, green constant (maxChanVal).

*** Predefined Schemes
 - =csCCudBr= :: \\
  [[./pics/cs/color_lut_docs_csCCudBr_50.png]]
 - =csCCudBg= :: \\
  [[./pics/cs/color_lut_docs_csCCudBg_50.png]]
 - =csCCudGr= :: \\
  [[./pics/cs/color_lut_docs_csCCudGr_50.png]]
 - =csCCudGb= :: \\
  [[./pics/cs/color_lut_docs_csCCudGb_50.png]]
 - =csCCudRg= :: \\
  [[./pics/cs/color_lut_docs_csCCudRg_50.png]]
 - =csCCudRb= :: \\
  [[./pics/cs/color_lut_docs_csCCudRb_50.png]]

** Three Segment Diverging Maps

 Some three edge trees utilizing very different colors for starting and terminal points can form very nice "divergent" color maps.  Such maps can
 successfully illustrate variables with both positive and negative values or two mutually exclusive, opposing variables.  Only two are directly
 supported via named methods (selected for attractiveness):

  - =BWR= -- intensity between 1 and 3
  - =CWM= -- intensity between 2 and 3

** Center point ramps (HSL schemes)

 Color schemes defined as gradients from the center of the HSL color space to an extreme edge are mostly perceptually linear.  These are also one segment
 trees in the complete cube graph with center.  Recall that we call the vertex at the center of the cube "=H=" -- for "Half way between everything". Using
 this new vertex, we have the following saturation based color schemes:

  - =HR= -- =csHSLhR=
  - =HG= -- =csHSLhG=
  - =HB= -- =csHSLhB=
  - =HC= -- =csHSLhC=
  - =HY= -- =csHSLhY=
  - =HM= -- =csHSLhM=

*** Predefined Schemes
 - =csHSLhR= :: \\
  [[./pics/cs/color_lut_docs_csHSLhR_50.png]]
 - =csHSLhG= :: \\
  [[./pics/cs/color_lut_docs_csHSLhG_50.png]]
 - =csHSLhB= :: \\
  [[./pics/cs/color_lut_docs_csHSLhB_50.png]]
 - =csHSLhC= :: \\
  [[./pics/cs/color_lut_docs_csHSLhC_50.png]]
 - =csHSLhY= :: \\
  [[./pics/cs/color_lut_docs_csHSLhY_50.png]]
 - =csHSLhM= :: \\
  [[./pics/cs/color_lut_docs_csHSLhM_50.png]]

** Stacked HSL Schemes

 The diagonal traversals (diagonal meaning through the center of the cube) are essentially two of the HSL saturation based schemes placed back to back.  Aside
 from the black-white one, these can form effective divergent color schemes.  

  - =CR= -- =csCCdiagCR=
  - =MG= -- =csCCdiagMG=
  - =YB= -- =csCCdiagYB=
  - =0W= -- =csCCdiag01=

*** Predefined Schemes
 - =csCCdiagCR= :: \\
  [[./pics/cs/color_lut_docs_csCCdiagCR_50.png]]
 - =csCCdiagMG= :: \\
  [[./pics/cs/color_lut_docs_csCCdiagMG_50.png]]
 - =csCCdiagYB= :: \\
  [[./pics/cs/color_lut_docs_csCCdiagYB_50.png]]
 - =csCCdiag01= :: \\
  [[./pics/cs/color_lut_docs_csCCdiag01_50.png]]

* Continuous Polynomial Schemes

These schemes are "continuous" in that they take a floating point value to select the color, and are derived from continuous polynomial curves in the RGB cube
space.  Many of them are very similar to color maps in popular use (with similar names), but these are only only similar to those popular maps.  In
particular, the maps here may not be as precise when it comes to things like monotonously of intensity.  That said these look nice and I like easy to compute
color maps that don't require fancy interpolating schemes.

 - =csPLYgrey= :: \\
  [[./pics/cs/color_lut_docs_csPLYgrey_50.png]]
 - =csPLYquad= :: \\
  [[./pics/cs/color_lut_docs_csPLYquad_50.png]]
 - =csPLYinferno= :: \\
  [[./pics/cs/color_lut_docs_csPLYinferno_50.png]]
 - =csPLYmagma= :: \\
  [[./pics/cs/color_lut_docs_csPLYmagma_50.png]]
 - =csPLYparula= :: \\
  [[./pics/cs/color_lut_docs_csPLYparula_50.png]]
 - =csPLYplasma= :: \\
  [[./pics/cs/color_lut_docs_csPLYplasma_50.png]]
 - =csPLYturbo= :: \\
  [[./pics/cs/color_lut_docs_csPLYturbo_50.png]]
 - =csPLYviridis= :: \\
  [[./pics/cs/color_lut_docs_csPLYviridis_50.png]]
 - =csPLYcividis= :: \\
  [[./pics/cs/color_lut_docs_csPLYcividis_50.png]]
 - =csPLYhsvRB= :: \\
  [[./pics/cs/color_lut_docs_csPLYhsvRB_50.png]]

* Dav Green's cubehelix color maps

The =csCubeHelix_tpl= templte can geneate any of the cubehelix schemes, but =colorTpl= predefines three I particularly like:

 - =csCHstd= :: \\
  [[./pics/cs/color_lut_docs_csCHstd_50.png]]
 - =csCHblu= :: \\
  [[./pics/cs/color_lut_docs_csCHblu_50.png]]
 - =csCHvio= :: \\
  [[./pics/cs/color_lut_docs_csCHvio_50.png]]

* Pseudo-Greyscale   

These schemes are not true greyscale, but the colors are very close to grey.  These schemes are discreet!

 - =csPGrey3x= :: \\
  [[./pics/cs/color_lut_docs_csPGrey3x_50.png]]
 - =csPGrey4x= :: \\
  [[./pics/cs/color_lut_docs_csPGrey4x_50.png]]

* Spectral

These color schemes are based on the spectrum and color match functions.  These aren't really suitable for visualization, but some
interesting color schemes can be derived from them.

 - =csRainbowLA= :: \\
  [[./pics/cs/color_lut_docs_csRainbowLA_50.png]]
 - =csRainbowCM= with =BUMP= :: \\
  [[./pics/cs/color_lut_docs_csRainbowCMb_50.png]]
 - =csRainbowCM= with =LINEAR= :: \\
  [[./pics/cs/color_lut_docs_csRainbowCMl_50.png]]
 - =csRainbowCM= with =FLOOR= :: \\
  [[./pics/cs/color_lut_docs_csRainbowCMf_50.png]]
 - =csRainbowCM= with =CEILING= :: \\
  [[./pics/cs/color_lut_docs_csRainbowCMc_50.png]]
 - =csRainbowCM= with =NEAREST= :: \\
  [[./pics/cs/color_lut_docs_csRainbowCMn_50.png]]

* Color Brewer

 - =csCBAccent= :: \\
  [[./pics/cs/color_lut_docs_csCBAccent_50.png]]
 - =csCBBlues= :: \\
  [[./pics/cs/color_lut_docs_csCBBlues_50.png]]
 - =csCBBrBG= :: \\
  [[./pics/cs/color_lut_docs_csCBBrBG_50.png]]
 - =csCBBuGn= :: \\
  [[./pics/cs/color_lut_docs_csCBBuGn_50.png]]
 - =csCBBuPu= :: \\
  [[./pics/cs/color_lut_docs_csCBBuPu_50.png]]
 - =csCBDark2= :: \\
  [[./pics/cs/color_lut_docs_csCBDark2_50.png]]
 - =csCBGnBu= :: \\
  [[./pics/cs/color_lut_docs_csCBGnBu_50.png]]
 - =csCBGreens= :: \\
  [[./pics/cs/color_lut_docs_csCBGreens_50.png]]
 - =csCBGreys= :: \\
  [[./pics/cs/color_lut_docs_csCBGreys_50.png]]
 - =csCBOranges= :: \\
  [[./pics/cs/color_lut_docs_csCBOranges_50.png]]
 - =csCBOrRd= :: \\
  [[./pics/cs/color_lut_docs_csCBOrRd_50.png]]
 - =csCBPaired= :: \\
  [[./pics/cs/color_lut_docs_csCBPaired_50.png]]
 - =csCBPastel1= :: \\
  [[./pics/cs/color_lut_docs_csCBPastel1_50.png]]
 - =csCBPastel2= :: \\
  [[./pics/cs/color_lut_docs_csCBPastel2_50.png]]
 - =csCBPiYG= :: \\
  [[./pics/cs/color_lut_docs_csCBPiYG_50.png]]
 - =csCBPRGn= :: \\
  [[./pics/cs/color_lut_docs_csCBPRGn_50.png]]
 - =csCBPuBuGn= :: \\
  [[./pics/cs/color_lut_docs_csCBPuBuGn_50.png]]
 - =csCBPuBu= :: \\
  [[./pics/cs/color_lut_docs_csCBPuBu_50.png]]
 - =csCBPuOr= :: \\
  [[./pics/cs/color_lut_docs_csCBPuOr_50.png]]
 - =csCBPuRd= :: \\
  [[./pics/cs/color_lut_docs_csCBPuRd_50.png]]
 - =csCBPurples= :: \\
  [[./pics/cs/color_lut_docs_csCBPurples_50.png]]
 - =csCBRdBu= :: \\
  [[./pics/cs/color_lut_docs_csCBRdBu_50.png]]
 - =csCBRdGy= :: \\
  [[./pics/cs/color_lut_docs_csCBRdGy_50.png]]
 - =csCBRdPu= :: \\
  [[./pics/cs/color_lut_docs_csCBRdPu_50.png]]
 - =csCBRdYlBu= :: \\
  [[./pics/cs/color_lut_docs_csCBRdYlBu_50.png]]
 - =csCBRdYlGn= :: \\
  [[./pics/cs/color_lut_docs_csCBRdYlGn_50.png]]
 - =csCBReds= :: \\
  [[./pics/cs/color_lut_docs_csCBReds_50.png]]
 - =csCBSet1= :: \\
  [[./pics/cs/color_lut_docs_csCBSet1_50.png]]
 - =csCBSet2= :: \\
  [[./pics/cs/color_lut_docs_csCBSet2_50.png]]
 - =csCBSet3= :: \\
  [[./pics/cs/color_lut_docs_csCBSet3_50.png]]
 - =csCBSpectral= :: \\
  [[./pics/cs/color_lut_docs_csCBSpectral_50.png]]
 - =csCBYlGnBu= :: \\
  [[./pics/cs/color_lut_docs_csCBYlGnBu_50.png]]
 - =csCBYlGn= :: \\
  [[./pics/cs/color_lut_docs_csCBYlGn_50.png]]
 - =csCBYlOrBr= :: \\
  [[./pics/cs/color_lut_docs_csCBYlOrBr_50.png]]
 - =csCBYlOrRd= :: \\
  [[./pics/cs/color_lut_docs_csCBYlOrRd_50.png]]

* Converting and processing previews                               :noexport:

In the build directory, we run the =color_lut_docs= example to generate all the TIFF files.

#+begin_src sh
make color_lut_docs && ./color_lut_docs.exe 
#+end_src

In this directory, we run the following to create PNGs:

#+begin_src zsh
for f in ../build/color_lut_docs_*.tiff(:r); do echo $f; nf=pics/cs/`basename $f`_50.png; convert $f.tiff $nf; done
for f in ../build/color_lut_docs_*.tiff(:r); do echo $f; nf=pics/cs/`basename $f`_50_50.png; convert -resize 50% $f.tiff $nf; done
#+end_src
